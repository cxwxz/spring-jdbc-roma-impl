{"name":"Spring-JDBC-ROMA","tagline":"Spring-JDBC-ROMA - Byte Code Generation Based ORM Like Row Mapper Framework","body":"CONTENTS\r\n=======\r\n\r\n- [1. What is Spring-JDBC-ROMA?](#Section_1)\r\n- [2. Features](#Section_2)\r\n- [3. Installation](#Section_3)\r\n- [4. Usage](#Section_4)\r\n    * [4.1. Default configurations](#Section_4_1)\r\n    * [4.2. Primitive Typed Field Features](#Section_4_2)\r\n    * [4.3. Date/Timestamp Typed Field Features](#Section_4_3)\r\n    * [4.4. Clob Typed Column Features](#Section_4_4)\r\n    * [4.5. Blob Typed Column Features](#Section_4_5)\r\n    * [4.6. Enum Typed Field Features](#Section_4_6)\r\n    * [4.7. Field Based Features Configuration Features](#Section_4_7)\r\n    * [4.8. Class (or Type) Based Configuration Features](#Section_4_8)\r\n    * [4.9. RXEL (ROMA Expression Language)](#Section_4_9)\r\n    * [4.10. Complex Typed Field Features](#Section_4_10)\r\n    * [4.11. Conditional Lazy Feature](#Section_4_11)\r\n    * [4.12. Conditional Lazy-Load Feature](#Section_4_12)\r\n    * [4.13. Conditional Ignore Feature](#Section_4_13)\r\n    * [4.14. Other Features](#Section_4_14)\r\n- [5. A Simple Example](#Section_5)\r\n- [6. Roadmap](#Section_6)\r\n\r\n<a name=\"Section_1\"></a>\r\n1. What is Spring-JDBC-ROMA?\r\n=======\r\n\r\n**Spring-JDBC-ROMA** is a rowmapper extension for **Spring-JDBC module**. \r\nThere is already a rowmapper named `org.springframework.jdbc.core.BeanPropertyRowMapper` for binding \r\nresultset attributes to object. But it is reflection based and can cause performance problems as Spring developers said.\r\nHowever **Spring-JDBC-ROMA** is not reflection based and it is byte code generation (with **CGLib** and **Javassist**) \r\nbased rowmapper. It generates rowmapper on the fly like implementing as manual so it has no performance overhead. \r\nIt also supports object relations as lazy and eager. There are other lots of interesting features and \r\nthese features can be customized with developer's extended classes. This is the web site URL [https://github.com/serkan-ozal/spring-jdbc-roma-impl](https://github.com/serkan-ozal/spring-jdbc-roma-impl).\r\n\r\n<a name=\"Section_2\"></a>\r\n2. Features\r\n=======\r\n\r\n* All primitive types, string, enum, date/timestamp, clob, blob, collections and complex objects are supported.  \r\n\r\n* Writing your custom class (or type) based field generator factory, object creater, object processor, table name resolver, column name resolver implementations and customizable data source, schema, table names are supported.  \r\n\r\n* Writing your custom field based mapper, SQL based binder, expression language based binder and custom binder implementations are supported.   \r\n \r\n* Lazy or eager field accessing is supported. Lazy support can be configured as conditional and conditions can be provided as expression language or as custom lazy condition provider implementations. If lazy condition is not enable, specified field is not handled as lazy and set as eager while creating root entity.\r\n\r\n* Loading lazy fields can be enable or disable at runtime dynamically by using key based, expression based and custom implementation based approaches. If lazy-load condition is not enable, specified lazy field is not loaded no matter field is configured as lazy.\r\n\r\n* Ignoring fields can be enable or disable at runtime dynamically by using key based, expression based and custom implementation based approaches. This feature is very useful in some use-cases. For example, this feature can be used to ignore some fields while serializing to JSON at your specified controller and this behaviour doesn't effect other controllers.\r\n\r\n* Writing field access definitions as REXL (ROMA Expression Language) or as compilable Java code in annotation. XML and properties file configuration support will be added soon.  \r\n\r\n<a name=\"Section_3\"></a>\r\n3. Installation\r\n=======\r\n\r\nIn your **pom.xml**, you must add repository and dependency for Spring-JDBC-ROMA. \r\nYou can change **spring.jdbc.roma.version** to any existing **spring-jdbc-roma** library version.\r\n\r\n~~~~~ xml\r\n...\r\n<properties>\r\n    ...\r\n    <spring.jdbc.roma.version>2.0.0-SNAPSHOT</spring.jdbc.roma.version>\r\n    ...\r\n</properties>\r\n...\r\n<dependencies>\r\n    ...\r\n\t<dependency>\r\n\t\t<groupId>org.springframework</groupId>\r\n\t\t<artifactId>spring-jdbc-roma</artifactId>\r\n\t\t<version>${spring.jdbc.roma.version}</version>\r\n\t</dependency>\r\n\t...\r\n</dependencies>\r\n...\r\n<repositories>\r\n\t...\r\n\t<repository>\r\n\t\t<id>serkanozal-maven-repository</id>\r\n\t\t<url>https://github.com/serkan-ozal/maven-repository/raw/master/</url>\r\n\t</repository>\r\n\t...\r\n</repositories>\r\n...\r\n~~~~~\r\n\r\nAnd finally, in your **Spring context xml** file add following configuration to make your Spring context automatically aware of Spring-JDBC-ROMA.\r\n\r\n~~~~~ xml\r\n...\r\n<import resource=\"classpath*:roma-context.xml\"/>\r\n...\r\n~~~~~\r\n\r\n<a name=\"Section_4\"></a>\r\n4. Usage\r\n=======\r\n\r\nYou must get your row mapper via service class (`org.springframework.jdbc.roma.impl.service.RowMapperService`) of ROMA.\r\n\r\n~~~~~ java\r\n@Autowired\r\nRowMapperService rowMapperService;\r\n    \r\n...\r\n\r\nRowMapper<User> userRowMapper = rowMapperService.getRowMapper(User.class);\r\n~~~~~\r\n\r\n<a name=\"Section_4_1\"></a>\r\n4.1. Default configurations\r\n-------\r\n\r\nDefault configurations are stored and accessed by `org.springframework.jdbc.roma.api.config.DefaultConfigs` class.\r\n\r\nConfigurable values as default are:\r\n\r\n* **Datasource name:** Name of the datasource to connect. Initial value of default datasource name is `dataSource`. So if you have defined your datasource named as `dataSource`, you don't need to configure this value.\r\n\r\n* **Schema name:** Name of the schema name in DB to connect. Initial value of default datasource name is `null`. So default schema of DB is used. If default schema of your connected DB is used, you don't need to configure this value.\r\n\r\nUsing default values are helpful if there are so many entities using same datasource and schema name configurations.\r\nIn addition to default values, you must configure these values based on entity and this will be mentioned in sections below. Note that initial default \r\n\r\nDefault configurations can be configured programatically or in context xml of Spring like:\r\n\r\n~~~~~ xml\r\n...\r\n<bean id=\"defaultConfigs\" class=\"org.springframework.jdbc.roma.api.config.DefaultConfigs\">\r\n\t<property name=\"defaultDataSourceName\" value=\"myDataSource\"/>\r\n\t<property name=\"defaultSchemaName\" value=\"myDBSchema\"/>\r\n</bean>\r\n...\r\n~~~~~\r\n\r\n<a name=\"Section_4_2\"></a>\r\n4.2. Primitive Typed Field Features\r\n-------\r\n\r\n* `boolean`\r\n* `byte`\r\n* `char`\r\n* `short`\r\n* `int`\r\n* `float`\r\n* `long`\r\n* `double`\r\n* `java.lang.Boolean`\r\n* `java.lang.Byte`\r\n* `java.lang.Character`\r\n* `java.lang.Short`\r\n* `java.lang.Integer`\r\n* `java.lang.Float`\r\n* `java.lang.Long`\r\n* `java.lang.Double`\r\n* `java.lang.String`  \r\n\r\ntyped fields are automatically mapped to result set in row mapper.\r\n\r\n<a name=\"Section_4_3\"></a>\r\n4.3. Date/Timestamp Typed Field Features\r\n-------\r\n\r\n`java.util.Date` typed fields are automatically mapped to result set as **Date** in row mapper. But if mapped column in database is defined as **Timestamp** typed, you can configure this field by using **`@RowMapperTimeField`** annotation as:\r\n\r\n~~~~~ java\r\n@RowMapperTimeField(asTimestamp = true)\r\nprivate Date date;\r\n~~~~~\r\n\r\nIn addition, `java.sql.Timestamp` typed fields are automatically mapped to result set as **Timestamp** in row mapper with no additional configuration. \r\n\r\n<a name=\"Section_4_4\"></a>\r\n4.4. Clob Typed Column Features\r\n-------\r\n\r\n`CLOB` typed column can be mapped to **`java.lang.String`** typed field by using **`@RowMapperClobField`** annotation like this:\r\n\r\n~~~~~ java\r\n@RowMapperClobField\r\nprivate String address;\r\n~~~~~\r\n\r\n<a name=\"Section_4_5\"></a>\r\n4.5. Blob Typed Column Features\r\n-------\r\n`BLOB` typed column can be mapped to **`byte[]`** typed field by using **`@RowMapperBlobField`** annotation like this:\r\n\r\n~~~~~ java\r\n@RowMapperBlobField\r\nprivate byte[] image;\r\n~~~~~\r\n\r\n<a name=\"Section_4_6\"></a>\r\n4.6. Enum Typed Field Features\r\n-------\r\n\r\nBy default, enums are mapped by using numeric column value as ordinal of enum. For example, you have an enum named `UserType` like this:\r\n\r\n~~~~~ java\r\npublic enum UserType {\r\n\r\n\tADMIN,\r\n\tMEMBER,\r\n\tGUEST\r\n\t\r\n}\r\n~~~~~\r\n\r\nIf numeric value of column is `1`, value is mapped to enum field as `MEMBER`.\r\n\r\nEnum mappings can be configured by using **`@RowMapperEnumField`** annotation.\r\n\r\n* **constantsAndMaps:** This feature is now depracated from version 2.0. With this configuration feature, you can map numeric value of column to String value of enum.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperEnumField(constantsAndMaps = {\"1:ADMIN\", \"2:MEMBER\", \"3:GUEST\"})\r\nprivate UserType userType;\r\n~~~~~\r\n\r\n* **enumStartValue:** With this configuration feature, numeric column value is mapped to enum ordinal by using start value as first element of enum. For example, you have an enum named `Language` like this:\r\n\r\n~~~~~ java\r\npublic enum Language {\r\n\r\n\tTURKISH,\r\n\tENGLISH,\r\n\tGERMAN,\r\n\t...\r\n}\r\n~~~~~\r\n\r\nand enum field is declared as like:\r\n\r\n~~~~~ java\r\n@RowMapperEnumField(enumStartValue = 1)\r\nprivate Language language;\r\n~~~~~\r\n\r\nIf numeric value of column is `1`, value is mapped to enum field as `TURKISH`. Because `enumStartValue` is `1` and actual ordinal will be `1 - 1 = 0`. So mapped value will be `TURKISH`.\r\n\r\n* **useStringValue:** By default, column value is mapped to enum value with its numeric value. With this configuration feature, column value is mapped to enum value with its string value by using name of enum value. For example, you have an enum named `Religion` like this:\r\n\r\n~~~~~ java\r\npublic enum Religion {\r\n\r\n\tMUSLIM,\r\n\tJEWISH,\r\n\tCHRISTIAN_CAHTOLICS,\r\n\tCHRISTIAN_ORTHODOX,\r\n\tCHRISTIAN_PROTESTANT,\r\n\tATHEIST,\r\n\tOTHER;\r\n\t\r\n}\r\n~~~~~\r\n\r\nand enum field is declared as like:\r\n\r\n~~~~~ java\r\n@RowMapperEnumField(useStringValue = true)\r\nprivate Religion religion;\r\n~~~~~\r\n\r\nIf string value of column is `\"MUSLIM\"`, value is mapped to enum field as `MUSLIM`. \r\n\r\n* **defaultIndex:** With this configuration feature, if column value is empty (null), this index value will be used as ordinal of enum value for default value of field. For example, you have an enum named `UserType` like this:\r\n\r\n~~~~~ java\r\npublic enum UserType {\r\n\r\n\tADMIN,\r\n\tMEMBER,\r\n\tGUEST\r\n\t\r\n}\r\n~~~~~\r\n\r\nand enum field is declared as like:\r\n\r\n~~~~~ java\r\n@RowMapperEnumField(defaultIndex = 2)\r\nprivate UserType userType;\r\n~~~~~\r\n\r\nIf column value is empty (null), value is mapped to enum field as `GUEST`. Because `defaultIndex` is `2` and ordinal will used as `2`. So mapped value will be `GUEST`.\r\n\r\n* **defaultValue:** With this configuration feature, if column value is empty (null), this index value will be used as name of enum value for default value of field. For example, you have an enum named `UserType` like this:\r\n\r\n~~~~~ java\r\npublic enum UserType {\r\n\r\n\tADMIN,\r\n\tMEMBER,\r\n\tGUEST\r\n\t\r\n}\r\n~~~~~\r\n\r\nand enum field is declared as like:\r\n\r\n~~~~~ java\r\n@RowMapperEnumField(defaultValue = \"GUEST\")\r\nprivate UserType userType;\r\n~~~~~\r\n\r\nIf column value is empty (null), value is mapped to enum field as `GUEST`. Since `defaultValue` is `\"GUEST\"`, mapped value will be `GUEST`.\r\n\r\n* **mapViaNumericMapper:** With this configuration feature by using **`@RowMapperEnumNumericMapper`** annotation in **`@RowMapperEnumField`** annotation, you can use your custom mapper implementations by implementing **`org.springframework.jdbc.roma.api.config.provider.annotation.RowMapperEnumField.NumericEnumMapper`** interface for numeric column values. Instance of your implementation is created once and used as singleton. For example, you have an enum named `BloodType` like this:\r\n\r\n~~~~~ java\r\npublic enum BloodType {\r\n\r\n\tTYPE_A_RH_POSITIVE(1),\r\n\tTYPE_A_RH_NEGATIVE(2),\r\n\tTYPE_B_RH_POSITIVE(3),\r\n\tTYPE_B_RH_NEGATIVE(4),\r\n\tTYPE_AB_RH_POSITIVE(5),\r\n\tTYPE_AB_RH_NEGATIVE(6),\r\n\tTYPE_0_RH_POSITIVE(7),\r\n\tTYPE_0_RH_NEGATIVE(8);\r\n\t\r\n\tint code;\r\n\t\r\n\tBloodType(int code) {\r\n\t\tthis.code = code;\r\n\t}\r\n\t\r\n\tpublic int getCode() {\r\n\t\treturn code;\r\n\t}\r\n\t\r\n}\r\n~~~~~\r\n\r\nyour custom numeric mapper implementation is declared as like:\r\n\r\n~~~~~ java\r\npublic class BloodTypeEnumMapper implements RowMapperEnumField.NumericEnumMapper<BloodType> {\r\n\r\n\t@Override\r\n\tpublic BloodType map(Integer value) {\r\n\t\tfor (BloodType bt : BloodType.values()) {\r\n\t\t\tif (bt.getCode() == value) {\r\n\t\t\t\treturn bt;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n}\r\n~~~~~\r\n\r\nand enum field is declared as like:\r\n\r\n~~~~~ java\r\n@RowMapperEnumField(\r\n\tmapViaNumericMapper = \r\n\t\t@RowMapperEnumNumericMapper(\r\n\t\t\tmapper = BloodTypeEnumMapper.class))\r\nprivate BloodType bloodType;\r\n~~~~~\r\n\r\n* **mapViaStringMapper:** With this configuration feature by using **`@RowMapperEnumStringMapper`** annotation in **`@RowMapperEnumField`** annotation, you can use your custom mapper implementations by implementing **`org.springframework.jdbc.roma.api.config.provider.annotation.RowMapperEnumField.StringEnumMapper`** interface for numeric column values. Instance of your implementation is created once and used as singleton. For example, you have an enum named `MaritalStatus` like this:\r\n\r\n~~~~~ java\r\npublic enum MaritalStatus {\r\n\r\n\tSINGLE,\r\n\tENGAGED,\r\n\tMARRIED,\r\n\tDIVORCED;\r\n\r\n}\r\n~~~~~\r\n\r\nyour custom numeric mapper implementation is declared as like:\r\n\r\n~~~~~ java\r\npublic class MaritalStatusEnumMapper implements RowMapperEnumField.StringEnumMapper<MaritalStatus> {\r\n\r\n\t@Override\r\n\tpublic MaritalStatus map(String value) {\r\n\t\tfor (MaritalStatus ms : MaritalStatus.values()) {\r\n\t\t\tif (ms.name().equalsIgnoreCase(value)) {\r\n\t\t\t\treturn ms;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n}\r\n~~~~~\r\n\r\nand enum field is declared as like:\r\n\r\n~~~~~ java\r\n@RowMapperEnumField(\r\n\tmapViaStringMapper = \r\n\t\t@RowMapperEnumStringMapper(\r\n\t\t\tmapper = MaritalStatusEnumMapper.class))\r\nprivate MaritalStatus maritalStatus;\r\n~~~~~\r\n\r\n* **mapViaNumericValueNumericMappings:** With this configuration feature by using **`@RowMapperEnumAutoMapper`** annotation in **`@RowMapperEnumField`** annotation, you can map numeric column values with ordinals of enum. For example, you have an enum named `Occupation` like this:\r\n\r\n~~~~~ java\r\npublic enum Occupation {\r\n\r\n\tOTHER(0),\r\n\tARCHITECT(100),\r\n\tDOCTOR(200),\r\n\tENGINEER(300),\r\n\tLAWYER(400),\r\n\tMUSICIAN(500),\r\n\tSTUDENT(600),\r\n\tTEACHER(700);\r\n\t\r\n\tint code;\r\n\t\r\n\tOccupation(int code) {\r\n\t\tthis.code = code;\r\n\t}\r\n\t\r\n\tpublic int getCode() {\r\n\t\treturn code;\r\n\t}\r\n\t\r\n}\r\n~~~~~\r\n\r\nand enum field is declared as like:\r\n\r\n~~~~~ java\r\n@RowMapperEnumField(\r\n\tmapViaAutoMapper = \r\n\t\t@RowMapperEnumAutoMapper(\r\n\t\t\tmapViaNumericValueNumericMappings = {\r\n\t\t\t\t@RowMapperEnumNumericValueNumericMapping(mappingIndex = 0, value = 0),\r\n\t\t\t\t@RowMapperEnumNumericValueNumericMapping(mappingIndex = 1, value = 100),\r\n\t\t\t\t@RowMapperEnumNumericValueNumericMapping(mappingIndex = 2, value = 200),\r\n\t\t\t\t@RowMapperEnumNumericValueNumericMapping(mappingIndex = 3, value = 300),\r\n\t\t\t\t@RowMapperEnumNumericValueNumericMapping(mappingIndex = 4, value = 400),\r\n\t\t\t\t@RowMapperEnumNumericValueNumericMapping(mappingIndex = 5, value = 500),\r\n\t\t\t\t@RowMapperEnumNumericValueNumericMapping(mappingIndex = 6, value = 600),\r\n\t\t\t\t@RowMapperEnumNumericValueNumericMapping(mappingIndex = 7, value = 700)}))\r\nprivate Occupation occupation;\r\n~~~~~\r\n\r\n* **mapViaNumericValueStringMappings:** With this configuration feature by using **`@RowMapperEnumAutoMapper`** annotation in **`@RowMapperEnumField`** annotation, you can map numeric column values with names of enum. For example, you have an enum named `Occupation` like this:\r\n\r\n~~~~~ java\r\npublic enum Occupation {\r\n\r\n\tOTHER(0),\r\n\tARCHITECT(100),\r\n\tDOCTOR(200),\r\n\tENGINEER(300),\r\n\tLAWYER(400),\r\n\tMUSICIAN(500),\r\n\tSTUDENT(600),\r\n\tTEACHER(700);\r\n\t\r\n\tint code;\r\n\t\r\n\tOccupation(int code) {\r\n\t\tthis.code = code;\r\n\t}\r\n\t\r\n\tpublic int getCode() {\r\n\t\treturn code;\r\n\t}\r\n\t\r\n}\r\n~~~~~\r\n\r\nand enum field is declared as like:\r\n\r\n~~~~~ java\r\n@RowMapperEnumField(\r\n\tmapViaAutoMapper = \r\n\t\t@RowMapperEnumAutoMapper(\r\n\t\t\tmapViaNumericValueStringMappings = {\r\n\t\t\t\t@RowMapperEnumNumericValueStringMapping(mappingValue = \"OTHER\", value = 0),\r\n\t\t\t\t@RowMapperEnumNumericValueStringMapping(mappingValue = \"ARCHITECT\", value = 100),\r\n\t\t\t\t@RowMapperEnumNumericValueStringMapping(mappingValue = \"DOCTOR\", value = 200),\r\n\t\t\t\t@RowMapperEnumNumericValueStringMapping(mappingValue = \"ENGINEER\", value = 300),\r\n\t\t\t\t@RowMapperEnumNumericValueStringMapping(mappingValue = \"LAWYER\", value = 400),\r\n\t\t\t\t@RowMapperEnumNumericValueStringMapping(mappingValue = \"MUSICIAN\", value = 500),\r\n\t\t\t\t@RowMapperEnumNumericValueStringMapping(mappingValue = \"STUDENT\", value = 600),\r\n\t\t\t\t@RowMapperEnumNumericValueStringMapping(mappingValue = \"TEACHER\", value = 700)}))\r\nprivate Occupation occupation;\r\n~~~~~\r\n\r\n\r\n* **mapViaStringValueNumericMappings:** With this configuration feature by using **`@RowMapperEnumAutoMapper`** annotation in **`@RowMapperEnumField`** annotation, you can map string column values with ordinals of enum. For example, you have an enum named `Education` like this:\r\n\r\n~~~~~ java\r\npublic enum Education {\r\n\r\n\tPRIMARY_SCHOOL,\r\n\tSECONDARY_SCHOOL,\r\n\tHIGH_SCHOOL,\r\n\tBACHELOR,\r\n\tMASTER,\r\n\tPHD,\r\n\tASSOCIATE_PROFESSOR,\r\n\tPROFESSOR,\r\n\tOTHER;\r\n\r\n}\r\n~~~~~\r\n\r\nand enum field is declared as like:\r\n\r\n~~~~~ java\r\n@RowMapperEnumField(\r\n\tmapViaAutoMapper = \r\n\t\t@RowMapperEnumAutoMapper(\r\n\t\t\tmapViaStringValueNumericMappings = {\r\n\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 0, value = \"PRIMARY_SCHOOL\"),\r\n\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 1, value = \"SECONDARY_SCHOOL\"),\r\n\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 2, value = \"HIGH_SCHOOL\"),\r\n\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 3, value = \"BACHELOR\"),\r\n\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 4, value = \"MASTER\"),\r\n\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 5, value = \"PHD\" ),\r\n\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 6, value = \"ASSOCIATE_PROFESSOR\"),\r\n\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 7, value = \"PROFESSOR\"),\r\n\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 8, value = \"OTHER\")}))\r\nprivate Education education;\r\n~~~~~\r\n\r\n* **mapViaStringValueStringMappings:** With this configuration feature by using **`@RowMapperEnumAutoMapper`** annotation in **`@RowMapperEnumField`** annotation, you can map string column values with names of enum. For example, you have an enum named `Education` like this:\r\n\r\n~~~~~ java\r\npublic enum Education {\r\n\r\n\tPRIMARY_SCHOOL,\r\n\tSECONDARY_SCHOOL,\r\n\tHIGH_SCHOOL,\r\n\tBACHELOR,\r\n\tMASTER,\r\n\tPHD,\r\n\tASSOCIATE_PROFESSOR,\r\n\tPROFESSOR,\r\n\tOTHER;\r\n\r\n}\r\n~~~~~\r\n\r\nand enum field is declared as like:\r\n\r\n~~~~~ java\r\n@RowMapperEnumField(\r\n\tmapViaAutoMapper = \r\n\t\t@RowMapperEnumAutoMapper(\r\n\t\t\tmapViaStringValueStringMappings = {\r\n\t\t\t\t@RowMapperEnumStringValueStringMapping(mappingValue = \"PRIMARY_SCHOOL\", value = \"PRIMARY_SCHOOL\"),\r\n\t\t\t\t@RowMapperEnumStringValueStringMapping(mappingValue = \"SECONDARY_SCHOOL\", value = \"SECONDARY_SCHOOL\"),\r\n\t\t\t\t@RowMapperEnumStringValueStringMapping(mappingValue = \"HIGH_SCHOOL\", value = \"HIGH_SCHOOL\"),\r\n\t\t\t\t@RowMapperEnumStringValueStringMapping(mappingValue = \"BACHELOR\", value = \"BACHELOR\"),\r\n\t\t\t\t@RowMapperEnumStringValueStringMapping(mappingValue = \"MASTER\", value = \"MASTER\"),\r\n\t\t\t\t@RowMapperEnumStringValueStringMapping(mappingValue = \"PHD\", value = \"PHD\" ),\r\n\t\t\t\t@RowMapperEnumStringValueStringMapping(mappingValue = \"ASSOCIATE_PROFESSOR\", value = \"ASSOCIATE_PROFESSOR\"),\r\n\t\t\t\t@RowMapperEnumStringValueStringMapping(mappingValue = \"PROFESSOR\", value = \"PROFESSOR\"),\r\n\t\t\t\t@RowMapperEnumStringValueStringMapping(mappingValue = \"OTHER\", value = \"OTHER\")}))\r\nprivate Education education;\r\n~~~~~\r\n\r\n<a name=\"Section_4_7\"></a>\r\n4.7. Field Based Features Configuration Features\r\n-------\r\nGeneral field configurations can be done by using **`@RowMappeField`** annotation.\r\n\r\nBy default, you don't need to specify column name for field if you use similar names for field and column in database. For similarity between field name and column name, default column name resolver generates some possible column names by using field name and check them by connecting to related table at database. Generated possible column names are in\r\n\r\n1. columnName\r\n2. columname\r\n3. COLUMNNAME\r\n4. column_Name\r\n5. colum_name\r\n6. COLUMN_NAME\r\n\r\nformats.\r\n\r\nFor example, if you have a field named `birthDate`, generated possible column names will be\r\n\r\n1. birthDate\r\n2. birthdate\r\n3. BIRTHDATE\r\n4. birth_Date\r\n5. birth_date\r\n6. BIRTH_DATE\r\n\r\n* **columnName:** With this configuration feature, you can specify column name of field to be mapped.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMappeField(columnName = \"username\")\r\nprivate String username;\r\n~~~~~\r\n\r\n* **fieldGenerator:** With this configuration feature, you can use your custom field generator implementations by implementing **`org.springframework.jdbc.roma.api.generator.RowMapperFieldGenerator`** interface for generating mapping statement. Instance of your implementation is created once and used as singleton. In you implementation, you can\r\n\r\n1. refer to created entity by using **`RowMapperFieldGenerator.GENERATED_OBJECT_NAME`** property,\r\n2. refer to resultset by using **`RowMapperFieldGenerator.RESULT_SET_ARGUMENT`** property,\r\n3. refer to row number by using **`RowMapperFieldGenerator.ROW_NUM_ARGUMENT`** property.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMappeField(fieldGenerator = UsernameFieldGenerator.class)\r\nprivate String username;\r\n~~~~~\r\n\r\nand your custom field generator implementation is declared as like:\r\n\r\n~~~~~ java\r\npublic class UsernameFieldGenerator implements RowMapperFieldGenerator {\r\n\r\n\t@Override\r\n\tpublic String generateFieldMapping(Field f) {\r\n\t\treturn \r\n\t\t\tRowMapperFieldGenerator.GENERATED_OBJECT_NAME + \r\n\t\t\t\t\".setUsername\" + \r\n\t\t\t\t\"(\" + \r\n\t\t\t\t\tRowMapperFieldGenerator.RESULT_SET_ARGUMENT + \".getString(\\\"username\\\")\" +\t\r\n\t\t\t\t\");\";\r\n\t}\r\n\r\n}\r\n~~~~~\r\n\r\n* **fieldMapper:** With this configuration feature, you can use your custom field mapper implementations by implementing **`org.springframework.jdbc.roma.api.config.provider.annotation.RowMapperField.RowMapperFieldMapper`** interface for mapping specified field from resultset. Instance of your implementation is created once and used as singleton.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperField(fieldMapper = RoleNameFieldMapper.class)\r\nprivate String name;\r\n~~~~~\r\n\r\nand your custom field mapper implementation is declared as like:\r\n\r\n~~~~~ java\r\npublic class RoleNameFieldMapper implements RowMapperFieldMapper<Role> {\r\n\r\n\tprivate static final Logger logger = Logger.getLogger(RoleNameFieldMapper.class);\r\n\t\r\n\t@Override\r\n\tpublic void mapField(Role role, String fieldName, ResultSet rs, int rowNum) {\r\n\t\ttry {\r\n\t\t\trole.setName(rs.getString(\"name\"));\r\n\t\t} \r\n\t\tcatch (SQLException e) {\r\n\t\t\tlogger.error(\"Error occured while mapping field \" + fieldName + \r\n\t\t\t\t\t\" in Role object from resultset\", e);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n~~~~~\r\n\r\n<a name=\"Section_4_8\"></a>\r\n4.8. Class (or Type) Based Configuration Features\r\n-------\r\n\r\nGeneral class (or type) configurations can be done by using **`@RowMappeClass`** annotation.\r\n\r\n* **dataSourceName:** With this configuration feature, you can specify name of the datasource to connect for this class (or type). Initial value of default datasource name is `dataSource`. So if you have defined your datasource named as `dataSource`, you don't need to configure this value.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperClass(dataSourceName = \"myDataSource\")\r\npublic class User {\r\n\t...\r\n}\r\n~~~~~\r\n\r\n* **schemaName:** With this configuration feature, you can specify name of the schema in database to connect for this class (or type). Initial value of default datasource name is `null`. So default schema of DB is used. If default schema of your connected DB is used, you don't need to configure this value.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperClass(schemaName = \"Production\")\r\npublic class User {\r\n\t...\r\n}\r\n~~~~~\r\n\r\n* **tableName:** With this configuration feature, you can specify name of the table to map this class (or type). By default, you don't need to specify table name for class if you use similar names for class and table in database. For similarity between class name and table name, default table name resolver generates some possible table names by using class name and check them by connecting to related table at database. Generated possible table names are in\r\n\r\n1. TableName\r\n2. tablename\r\n3. TABLENAME\r\n4. Table_Name\r\n5. table_name\r\n6. TABLE_NAME\r\n\r\nformats.\r\n\r\nFor example, if you have a class named `SystemLog`, generated possible table names will be\r\n\r\n1. SystemLog\r\n2. systemlog\r\n3. SYSTEMLOG\r\n4. System_Log\r\n5. system_log\r\n6. SYSTEM_LOG\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperClass(tableName = \"USERS\")\r\npublic class User {\r\n\t...\r\n}\r\n~~~~~\r\n\r\n* **fieldGeneratorFactory:** With this configuration feature, you can use your custom field generator factory implementations by implementing **`org.springframework.jdbc.roma.api.factory.RowMapperGeneratorFactory`** interface for creating field generators. Instance of your implementation is created once and used as singleton. For example you have a class named `User` and you will use your custom field generator factory class.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperClass(fieldGeneratorFactory = UserFieldGeneratorFactory.class)\r\npublic class User {\r\n\t...\r\n}\r\n~~~~~\r\n\r\nand your custom field generator factory implementation is declared as like:\r\n\r\n~~~~~ java\r\npublic class UserFieldGeneratorFactory implements RowMapperFieldGeneratorFactory<User> {\r\n\r\n\t@Override\r\n\tpublic RowMapperFieldGenerator<User> createRowMapperFieldGenerator(Field f) {\r\n\t\tif (f.getType().equals(int.class) || f.getType().equals(Integer.class)) {\r\n\t\t\treturn new MyIntegerFieldGenerator(f);\r\n\t\t}\r\n\t\t...\r\n\t}\r\n\r\n}\r\n~~~~~\r\n\r\n* **objectCreater:** With this configuration feature, you can use your custom object creater implementations by implementing **`org.springframework.jdbc.roma.api.config.provider.annotation.RowMapperClass.RowMapperObjectCreater`** interface for creating entities. Instance of your implementation is created once and used as singleton. For example you have a class named `Role` and you will use your custom object creater class.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperClass(objectCreater = RoleObjectCreater.class)\r\npublic class Role {\r\n\t...\r\n}\r\n~~~~~\r\n\r\nand your custom object creater implementation is declared as like:\r\n\r\n~~~~~ java\r\npublic class RoleObjectCreater implements RowMapperObjectCreater<Role> {\r\n\r\n\t@Override\r\n\tpublic Role createObject(Class<Role> clazz) {\r\n\t\treturn new Role();\r\n\t}\r\n\r\n}\r\n~~~~~\r\n\r\n* **objectProcessor:** With this configuration feature, you can use your custom object processor implementations by implementing **`org.springframework.jdbc.roma.api.config.provider.annotation.RowMapperClass.RowMapperObjectProcessor`** interface for creating entities. Instance of your implementation is created once and used as singleton. Object processor class is called after all fields have been mapped from result set before object is returned from rowmapper. For example you have a class named `User` and you will use your custom object processor class. By your custom object processor class, you will set `age` field that is not present in database table of `User` object since it can be calculated by using `birthDate` field.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperClass(objectProcessor = UserObjectProcessor.class)\r\npublic class User {\r\n\t...\r\n}\r\n~~~~~\r\n\r\nand your custom object processor implementation is declared as like:\r\n\r\n~~~~~ java\r\npublic class UserObjectProcessor implements RowMapperObjectProcessor<User> {\r\n\r\n\t@SuppressWarnings(\"deprecation\")\r\n\t@Override\r\n\tpublic void processObject(User user, ResultSet rs, int rowNum) {\r\n\t\tif (user.getBirthDate() != null) {\r\n\t\t\tuser.setAge((byte)(Calendar.getInstance().getTime().getYear() - user.getBirthDate().getYear()));\r\n\t\t}\r\n\t}\r\n\r\n}\r\n~~~~~\r\n\r\n* **columnNameResolver:** With this configuration feature, you can use your custom column name resolver implementations by implementing **`org.springframework.jdbc.roma.api.config.provider.annotation.RowMapperClass.RowMapperColumnNameResolver`** interface for resolving column name of fields. Instance of your implementation is created once and used as singleton. For example you have a class named `User` and you will use your custom field generator factory class.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperClass(columnNameResolver = UserColumnNameResolver.class)\r\npublic class User {\r\n\t...\r\n}\r\n~~~~~\r\n\r\nand your custom column name resolver implementation is declared as like:\r\n\r\n~~~~~ java\r\npublic class UserColumnNameResolver implements RowMapperColumnNameResolver {\r\n\r\n\t@Override\r\n\tpublic String resolveColumnName(Field f) {\r\n\t\treturn f.getName().toLowerCase();\r\n\t}\r\n\r\n}\r\n~~~~~\r\n\r\n* **tableNameResolver:** With this configuration feature, you can use your custom table name resolver implementations by implementing **`org.springframework.jdbc.roma.api.config.provider.annotation.RowMapperClass.RowMapperTableNameResolver`** interface for resolving table name of classes. Instance of your implementation is created once and used as singleton. For example you have a class named `User` and you will use your custom field generator factory class.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperClass(tableNameResolver = UserTableNameResolver.class)\r\npublic class User {\r\n\t...\r\n}\r\n~~~~~\r\n\r\nand your custom table name resolver implementation is declared as like:\r\n\r\n~~~~~ java\r\npublic class UserTableNameResolver implements RowMapperTableNameResolver {\r\n\r\n\t@Override\r\n\tpublic String resolveTableName(Class<?> clazz) {\r\n\t\treturn clazz.getSimpleName().toUpperCase();\r\n\t}\r\n\r\n}\r\n~~~~~ \r\n\r\n<a name=\"Section_4_9\"></a>\r\n4.9. RXEL (ROMA Expression Language)\r\n-------\r\n\r\nROMA has a specific expression language named **ROMA Expression Language (REXL)** for customizing some implementations in short like any other expression languages such as Spring expression language.\r\n\r\n4.9.1. Using beans in expressions\r\n-------\r\nWith **`@`** sign you can use Spring beans in your expression language.\r\n\r\nFor example:\r\n`@{userDao}.list()` expression is executed as calling `list` method in Spring bean with id `userDao`.\r\n\r\n4.9.2. Using properties in expressions\r\n-------\r\nWith **`$`** sign you can use properties of created entity in your expression language.\r\n\r\nFor example:\r\n`@{roleDao}.list(${id})` expression is executed as calling `list` method in Spring bean with id `roleDao` by passing `id` property of created entity as argument.\r\n\r\n4.9.3. Using attributes in expressions\r\n-------\r\nWith **`#`** sign you can get any attribute of any object in your expression language. \r\n\r\nFor example:\r\n`@{userDao}.getAdmin().#{name}` expression is executed as calling `getAdmin` method in Spring bean with id `userDao` and return `name` attribute of returning object (possibly User entity) from `getAdmin` call.\r\n\r\n4.9.4. Using result set in expressions\r\n-------\r\nWith **`&`** sign you can use result set attributes in your expression language. But in your expression, you must indicate type of the requested attribute between **`[`** and **`]`** signs.\r\n\r\nFor example:\r\n`&{[int]enable} == 0 ? \"false\" : \"true\"` expression is executed as calling `getInt(\"enable\")` method in result set and checks its value to return `true` or `false`.\r\n\r\n<a name=\"Section_4_10\"></a>\r\n4.10. Complex Typed Field Features\r\n-------\r\n\r\n* **provideViaExpressionProvider:** With this configuration feature, you can use RXEL (ROMA Expression Language) expression language for providing field value.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperObjectField(\r\n\tprovideViaExpressionProvider = \r\n\t\t@RowMapperExpressionProvider(expression = \"@{roleDAO}.getUserRoleList(${id})\"))\r\nprivate List<Role> roles;\r\n~~~~~\r\n\r\n* **provideViaSqlProvider:** With this configuration feature, you can specify SQL query will be executed to provide value of field by using limited supported version of RXEL. Only property (**`${...}`**) and resultset (**`&{[...]...}`**) based expressions are supported in specified SQL query. If your field is collection typed (Only List type is supported for SQL provide feature), you must specify element type by using **`entityType`** property. In addition, you can specify name of datasource where SQL query will be executed by using **`dataSourceName`** property.\r\n\r\nFor example:\r\n~~~~~ java\r\nRowMapperObjectField(\r\n\tprovideViaSqlProvider = \r\n\t\t@RowMapperSqlProvider(\r\n\t                provideSql = \r\n\t                    \"SELECT p.* FROM PERMISSION p WHERE p.ID IN \" +\r\n\t                    \"(\" +\r\n\t                        \"SELECT rp.PERMISSION_ID FROM role_permission rp WHERE rp.ROLE_ID = ${id}\" +\r\n\t                    \") ORDER BY p.name\",\r\n\t                entityType = Permission.class),\t    \r\n\t        ...)\r\nprivate List<Permission> permissions;\r\n~~~~~ \r\n\r\nAlso, there are a way to customizing SQL query with its parameters by using your custom SQL query info provider implementations by implementing **`org.springframework.jdbc.roma.api.config.provider.annotation.RowMapperSqlProvider.RowMapperSqlQueryInfoProvider`** interface for providing SQL query info. Instance of your implementation is created once and used as singleton. Your custom SQL query info provider class returns a **`org.springframework.jdbc.roma.api.config.provider.annotation.RowMapperSqlProvider.SqlQueryInfo`** typed object and this objects contains SQL query to execute and its parameters as **`Object[]`** array. Note that **RXEL** is **not supported** in SQL query for this feature and you must use **`?`** as placeholder for parameter in query.\r\n \r\nFor example:\r\n~~~~~ java\r\n@RowMapperObjectField(\r\n\tprovideViaSqlProvider = \r\n\t\t@RowMapperSqlProvider(\r\n\t\t\tsqlQueryInfoProvider = UserAccountInfoSqlQueryInfoProvider.class))\r\nprivate AccountInfo accountInfo;\r\n~~~~~\r\n\r\nand your custom SQL query info provider implementation is declared as like:\r\n\r\n~~~~~ java\r\npublic class UserAccountInfoSqlQueryInfoProvider implements RowMapperSqlQueryInfoProvider<User> {\r\n\r\n\t@Override\r\n\tpublic SqlQueryInfo provideSqlQueryInfo(User user, String fieldName) {\r\n\t\treturn \r\n\t\t\tnew SqlQueryInfo(\r\n\t\t\t\t\"SELECT a.* FROM ACCOUNT_INFO a WHERE a.ID IN \" +\r\n\t            \"(\" +\r\n\t                \"SELECT ua.account_info_id FROM USER_ACCOUNT_INFO ua WHERE ua.user_id = ?\" +\r\n\t            \")\",\r\n\t            new Object[] { user.getId() });\r\n\t}\r\n\r\n}\r\n~~~~~ \r\n\r\n* **provideViaCustomProvider:** With this configuration feature, you can use your custom field value provider implementations by implementing **`org.springframework.jdbc.roma.api.config.provider.annotation.RowMapperCustomProvider.RowMapperFieldProvider`** interface for providing value of field. Instance of your implementation is created once and used as singleton. \r\n \r\nFor example:\r\n~~~~~ java\r\n@RowMapperObjectField(\r\n\tprovideViaCustomProvider = \r\n\t\t@RowMapperCustomProvider(\r\n\t\t\tfieldProvider = UserPhoneNumberFieldProvider.class))\r\nprivate String phoneNumber;\r\n~~~~~\r\n\r\nand your custom field provider implementation is declared as like:\r\n\r\n~~~~~ java\r\npublic class UserPhoneNumberFieldProvider implements RowMapperFieldProvider<User, String> {\r\n\r\n\tprivate final static Logger logger = Logger.getLogger(UserPhoneNumberFieldProvider.class);\r\n\t\r\n\t@Override\r\n\tpublic String provideField(User user, String fieldName, ResultSet rs, int rowNum) {\r\n\t\ttry {\r\n\t\t\treturn rs.getString(\"phone_number\");\r\n\t\t} \r\n\t\tcatch (SQLException e) {\r\n\t\t\tlogger.error(\"Error occured while mapping field \" + fieldName + \" in User object from resultset\", e);\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n~~~~~ \r\n\r\n* **lazy:** With this configuration feature, you can configure this field as lazy permanently if **`lazyCondition`** is not specified. Note that specified field type must not **`final`** class.\r\n\r\n* **lazyCondition:** With this configuration feature, you can configure conditional lazy feature mentioned at section **`4.11. Conditional Lazy Feature`**.\r\n\r\n* **lazyLoadCondition:** With this configuration feature, you can configure conditional lazy-load feature mentioned at section **`4.12. Conditional Lazy-Load Feature`**.\r\n\r\n* **ignoreCondition:** With this configuration feature, you can configure conditional ignore feature mentioned at section **`4.13. Conditional Ignore Feature`**.\r\n\r\n<a name=\"Section_4_11\"></a>\r\n4.11. Conditional Lazy Feature\r\n-------\r\n\r\nConditional lazy feature can be configured by using **`@RowMapperLazyCondition`** annotation in **`@RowMapperObjectField`** annotation with **`lazyCondition`** attribute. With conditional lazy feature, you can control lazy feature of any field as dynamic at runtime. \r\n\r\n* **provideViaPropertyBasedProvider:** With this configuration feature, you can attach a specific property to a lazy condition and enable/disable condition of this property is used to evaluate condition.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperObjectField(\r\n\t...\r\n\tlazyCondition = \r\n\t\t@RowMapperLazyCondition(\r\n\t\t\tprovideViaPropertyBasedProvider = \r\n\t\t\t\t@RowMapperPropertyBasedLazyConditionProvider(\r\n\t\t\t\t\tpropertyName = \"creditCardInfoLazyCondition\")))\r\nprivate CreditCardInfo creditCardInfo;\r\n~~~~~\r\n\r\nTo enable/disable lazy condition property, there are two ways:\r\n\r\n1. You can enable/disable lazy condition property by using **`enableLazyConditionProperty`** and **`disableLazyConditionProperty`** methods of **`org.springframework.jdbc.roma.impl.service.RowMapperService`** service class.\r\n\r\nFor example you can get row mapper service class as:\r\n~~~~~ java\r\n@Autowired\r\nprivate RowMapperService;\r\n~~~~~\r\n\r\nand you can enable lazy condition property as:\r\n\r\n~~~~~ java\r\nrowMapperService.enableLazyConditionProperty(\"creditCardInfoLazyCondition\");\r\n~~~~~\r\n\r\nor you can disable lazy condition property as:\r\n\r\n~~~~~ java\r\nrowMapperService.disableLazyConditionProperty(\"creditCardInfoLazyCondition\");\r\n~~~~~\r\n\r\n2. You can enable/disable lazy condition property automatically by using **`@RowMapperPropertyBasedLazyConditionAware`** annotation on any method of any class in Spring context before database access code is executed. To enable/disable this property on start of this method and on end of this method can be configured by **`options`** property.\r\n\r\nFor example you can setup lazy condition configuration automatically by annotation like:\r\n~~~~~ java\r\n@Override\r\n@RowMapperPropertyBasedLazyConditionAware(\r\n\tpropertyName = \"creditCardInfoLazyCondition\",\r\n\toptions = \tRowMapperPropertyBasedLazyConditionAware.ENABLE_ON_START | \r\n\t\t\t\tRowMapperPropertyBasedLazyConditionAware.DISABLE_ON_FINISH)\r\npublic CreditCardInfo getUserCreditCardInfo(Long userId) {\r\n\t...\r\n}\r\n~~~~~\r\n\r\n* **provideViaExpressionBasedProvider:** With this configuration feature, you can use RXEL (ROMA Expression Language) expression language to evaluate lazy condition.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperObjectField(\r\n\t...\r\n\tlazyCondition = \r\n\t\t@RowMapperLazyCondition(\r\n\t\t\tprovideViaExpressionBasedProvider = \r\n\t\t\t\t@RowMapperExpressionBasedLazyConditionProvider(\r\n\t\t\t\t\texpression = \"${name}.equals(\\\"Member\\\")\")))\r\nprivate List<Permission> permissions;\r\n~~~~~\r\n\r\n* **provideViaCustomProvider:** With this configuration feature, you can use your custom lazy condition evaluater implementations by implementing **`org.springframework.jdbc.roma.api.config.provider.annotation.RowMapperLazyCondition.RowMapperLazyConditionProvider`** interface for evaluating lazy condition as custom. Instance of your implementation is created once and used as singleton.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperObjectField(\r\n\t...\r\n\tlazyCondition = \r\n\t\t@RowMapperLazyCondition(\r\n\t\t\tprovideViaCustomProvider = \r\n\t\t\t\t@RowMapperCustomLazyConditionProvider(\r\n\t\t\t\t\tlazyConditionProvider = UserRolesLazyConditionProvider.class)))\r\nprivate List<Role> roles;\r\n~~~~~\r\n\r\nand your custom lazy condition checker implementation is declared as like:\r\n\r\n~~~~~ java\r\npublic class UserRolesLazyConditionProvider implements RowMapperLazyConditionProvider<User> {\r\n\r\n\tprivate final static Logger logger = Logger.getLogger(UserRolesLazyConditionProvider.class);\r\n\t\r\n\t@Override\r\n\tpublic boolean evaluateCondition(User user, String fieldName, ResultSet rs, int rowNum) {\r\n\t\tboolean conditionResult = user.getId() % 2 == 0;\r\n\t\tlogger.debug(\"Evaluated lazy condition of field \" + \"\\\"\" + fieldName + \"\\\"\" +  \r\n\t\t\t \" for user with id \" + \"\\\"\" + user.getId() + \"\\\"\" + \" as \" + \"\\\"\" + conditionResult + \"\\\"\");\r\n\t\treturn conditionResult;\r\n\t}\r\n\r\n}\r\n~~~~~\r\n\r\n<a name=\"Section_4_12\"></a>\r\n4.12. Conditional Lazy-Load Feature\r\n-------\r\n\r\nConditional lazy-load feature can be configured by using **`@RowMapperLazyLoadCondition`** annotation in **`@RowMapperObjectField`** annotation with **`lazyLoadCondition`** attribute. With conditional lazy-load feature, you can control real object loading behaviour of any lazy field as dynamic at runtime. \r\n\r\n* **provideViaPropertyBasedProvider:** With this configuration feature, you can attach a specific property to a lazy-load condition and enable/disable condition of this property is used to evaluate condition.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperObjectField(\r\n\t...\r\n\tlazyLoadCondition = \r\n\t\t@RowMapperLazyLoadCondition(\r\n\t\t\tprovideViaPropertyBasedProvider = \r\n\t\t\t\t@RowMapperPropertyBasedLazyLoadConditionProvider(\r\n\t\t\t\t\tpropertyName = \"creditCardInfoLazyLoadCondition\")))\r\nprivate CreditCardInfo creditCardInfo;\r\n~~~~~\r\n\r\nTo enable/disable lazy-load condition property, there are two ways:\r\n\r\n1. You can enable/disable lazy-load condition property by using **`enableLazyLoadConditionProperty`** and **`disableLazyLoadConditionProperty`** methods of **`org.springframework.jdbc.roma.impl.service.RowMapperService`** service class.\r\n\r\nFor example you can get row mapper service class as:\r\n~~~~~ java\r\n@Autowired\r\nprivate RowMapperService;\r\n~~~~~\r\n\r\nand you can enable lazy-load condition property as:\r\n\r\n~~~~~ java\r\nrowMapperService.enableLazyLoadConditionProperty(\"creditCardInfoLazyLoadCondition\");\r\n~~~~~\r\n\r\nor you can disable lazy-load condition property as:\r\n\r\n~~~~~ java\r\nrowMapperService.disableLazyLoadConditionProperty(\"creditCardInfoLazyLoadCondition\");\r\n~~~~~\r\n\r\n2. You can enable/disable lazy-load condition property automatically by using **`@RowMapperPropertyBasedLazyLoadConditionAware`** annotation on any method of any class in Spring context before database access code is executed. To enable/disable this property on start of this method and on end of this method can be configured by **`options`** property.\r\n\r\nFor example you can setup lazy-load condition configuration automatically by annotation like:\r\n~~~~~ java\r\n@Override\r\n@RowMapperPropertyBasedLazyLoadConditionAware(\r\n\tpropertyName = \"creditCardInfoLazyLoadCondition\",\r\n\toptions = \tRowMapperPropertyBasedLazyLoadConditionAware.ENABLE_ON_START | \r\n\t\t\t\tRowMapperPropertyBasedLazyLoadConditionAware.DISABLE_ON_FINISH)\r\npublic CreditCardInfo getUserCreditCardInfo(Long userId) {\r\n\t...\r\n}\r\n~~~~~\r\n\r\n* **provideViaExpressionBasedProvider:** With this configuration feature, you can use RXEL (ROMA Expression Language) expression language to evaluate lazy-load condition.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperObjectField(\r\n\t...\r\n\tlazyLoadCondition = \r\n\t\t@RowMapperLazyLoadCondition(\r\n\t\t\tprovideViaExpressionBasedProvider = \r\n\t\t\t\t@RowMapperExpressionBasedLazyLoadConditionProvider(\r\n\t\t\t\t\texpression = \"${name}.equals(\\\"Member\\\")\")))\r\nprivate List<Permission> permissions;\r\n~~~~~\r\n\r\n* **provideViaCustomProvider:** With this configuration feature, you can use your custom lazy-load condition evaluater implementations by implementing **`org.springframework.jdbc.roma.api.config.provider.annotation.RowMapperLazyLoadCondition.RowMapperLazyLoadConditionProvider`** interface for evaluating lazy-load condition as custom. Instance of your implementation is created once and used as singleton.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperObjectField(\r\n\t...\r\n\tlazyLoadCondition = \r\n\t\t@RowMapperLazyLoadCondition(\r\n\t\t\tprovideViaCustomProvider = \r\n\t\t\t\t@RowMapperCustomLazyLoadConditionProvider(\r\n\t\t\t\t\tlazyLoadConditionProvider = UserRolesLazyLoadConditionProvider.class)))\r\nprivate List<Role> roles;\r\n~~~~~\r\n\r\nand your custom lazy-load condition checker implementation is declared as like:\r\n\r\n~~~~~ java\r\npublic class UserRolesLazyLoadConditionProvider implements RowMapperLazyLoadConditionProvider<User> {\r\n\r\n\tprivate final static Logger logger = Logger.getLogger(UserRolesLazyLoadConditionProvider.class);\r\n\t\r\n\t@Override\r\n\tpublic boolean evaluateCondition(User user, String fieldName) {\r\n\t\tboolean conditionResult = user.getId() % 2 == 0;\r\n\t\tlogger.debug(\"Evaluated lazy-load condition of field \" + \"\\\"\" + fieldName + \"\\\"\" +  \r\n\t\t\t \" for user with id \" + \"\\\"\" + user.getId() + \"\\\"\" + \" as \" + \"\\\"\" + conditionResult + \"\\\"\");\r\n\t\treturn conditionResult;\r\n\t}\r\n\r\n}\r\n~~~~~\r\n\r\n<a name=\"Section_4_13\"></a>\r\n4.13. Conditional Ignore Feature\r\n-------\r\n\r\nConditional ignore feature can be configured by using **`@RowMapperIgnoreCondition`** annotation in **`@RowMapperObjectField`** annotation with **`ignoreCondition`** attribute. With conditional ignore feature, you can control turning on/off of mapping behaviour of any field as dynamic at runtime. \r\n\r\n* **provideViaPropertyBasedProvider:** With this configuration feature, you can attach a specific property to a ignore condition and enable/disable condition of this property is used to evaluate condition.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperObjectField(\r\n\t...\r\n\tignoreCondition = \r\n\t\t@RowMapperIgnoreCondition(\r\n\t\t\tprovideViaPropertyBasedProvider = \r\n\t\t\t\t@RowMapperPropertyBasedIgnoreConditionProvider(\r\n\t\t\t\t\tpropertyName = \"creditCardInfoIgnoreCondition\")))\r\nprivate CreditCardInfo creditCardInfo;\r\n~~~~~\r\n\r\nTo enable/disable ignore condition property, there are two ways:\r\n\r\n1. You can enable/disable ignore condition property by using **`enableIgnoreConditionProperty`** and **`disableIgnoreConditionProperty`** methods of **`org.springframework.jdbc.roma.impl.service.RowMapperService`** service class.\r\n\r\nFor example you can get row mapper service class as:\r\n~~~~~ java\r\n@Autowired\r\nprivate RowMapperService;\r\n~~~~~\r\n\r\nand you can enable ignore condition property as:\r\n\r\n~~~~~ java\r\nrowMapperService.enableIgnoreConditionProperty(\"creditCardInfoIgnoreCondition\");\r\n~~~~~\r\n\r\nor you can disable ignore condition property as:\r\n\r\n~~~~~ java\r\nrowMapperService.disableIgnoreConditionProperty(\"creditCardInfoIgnoreCondition\");\r\n~~~~~\r\n\r\n2. You can enable/disable ignore condition property automatically by using **`@RowMapperPropertyBasedIgnoreConditionAware`** annotation on any method of any class in Spring context before database access code is executed. To enable/disable this property on start of this method and on end of this method can be configured by **`options`** property.\r\n\r\nFor example you can setup ignore condition configuration automatically by annotation like:\r\n~~~~~ java\r\n@Override\r\n@RowMapperPropertyBasedIgnoreConditionAware(\r\n\tpropertyName = \"creditCardInfoIgnoreCondition\",\r\n\toptions = \tRowMapperPropertyBasedIgnoreConditionAware.ENABLE_ON_START | \r\n\t\t\t\tRowMapperPropertyBasedIgnoreConditionAware.DISABLE_ON_FINISH)\r\npublic CreditCardInfo getUserCreditCardInfo(Long userId) {\r\n\t...\r\n}\r\n~~~~~\r\n\r\n* **provideViaExpressionBasedProvider:** With this configuration feature, you can use RXEL (ROMA Expression Language) expression language to evaluate ignore condition.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperObjectField(\r\n\t...\r\n\tignoreCondition = \r\n\t\t@RowMapperIgnoreCondition(\r\n\t\t\tprovideViaExpressionBasedProvider = \r\n\t\t\t\t@RowMapperExpressionBasedIgnoreConditionProvider(\r\n\t\t\t\t\texpression = \"${name}.equals(\\\"Member\\\")\")))\r\nprivate List<Permission> permissions;\r\n~~~~~\r\n\r\n* **provideViaCustomProvider:** With this configuration feature, you can use your custom ignore condition evaluater implementations by implementing **`org.springframework.jdbc.roma.api.config.provider.annotation.RowMapperIgnoreCondition.RowMapperIgnoreConditionProvider`** interface for evaluating ignore condition as custom. Instance of your implementation is created once and used as singleton.\r\n\r\nFor example:\r\n~~~~~ java\r\n@RowMapperObjectField(\r\n\t...\r\n\tignoreCondition = \r\n\t\t@RowMapperIgnoreCondition(\r\n\t\t\tprovideViaCustomProvider = \r\n\t\t\t\t@RowMapperCustomIgnoreConditionProvider(\r\n\t\t\t\t\tignoreConditionProvider = UserRolesIgnoreConditionProvider.class)))\r\nprivate List<Role> roles;\r\n~~~~~\r\n\r\nand your custom ignore condition checker implementation is declared as like:\r\n\r\n~~~~~ java\r\npublic class UserRolesIgnoreConditionProvider implements RowMapperIgnoreConditionProvider<User> {\r\n\r\n\tprivate final static Logger logger = Logger.getLogger(UserRolesIgnoreConditionProvider.class);\r\n\t\r\n\t@Override\r\n\tpublic boolean evaluateCondition(User user, String fieldName) {\r\n\t\tboolean conditionResult = user.getId() % 2 == 0;\r\n\t\tlogger.debug(\"Evaluated ignore condition of field \" + \"\\\"\" + fieldName + \"\\\"\" +  \r\n\t\t\t \" for user with id \" + \"\\\"\" + user.getId() + \"\\\"\" + \" as \" + \"\\\"\" + conditionResult + \"\\\"\");\r\n\t\treturn conditionResult;\r\n\t}\r\n\r\n}\r\n~~~~~\r\n\r\n<a name=\"Section_4_14\"></a>\r\n4.14. Other Features\r\n-------\r\n\r\n* **Ignoring field:** To hide field from row mapper, you can declare this field as **`transient`** or annotate it with **`@RowMapperIgnoreField`** annotation.\r\n\r\n<a name=\"Section_5\"></a>\r\n5. A Simple Example\r\n=======\r\n\r\nHere is `User` class:  \r\n\r\n~~~~~ java\r\n@RowMapperClass(objectProcessor = UserObjectProcessor.class)\r\npublic class User {\r\n\r\n\tprivate Long id;\r\n\tprivate String username;\r\n\tprivate String password;\r\n\tprivate String firstname;\r\n\tprivate String lastname;\r\n\t@RowMapperObjectField(\r\n\t\tprovideViaCustomProvider = \r\n\t\t\t@RowMapperCustomProvider(\r\n\t\t\t\t\tfieldProvider = UserPhoneNumberFieldProvider.class))\r\n\tprivate String phoneNumber;\r\n\t@RowMapperObjectField(\r\n\t\tprovideViaExpressionProvider = \r\n\t\t\t@RowMapperExpressionProvider(\r\n\t\t\t\t\texpression = \"new Address(&{[string]city}, &{[string]country})\",\r\n\t\t\t\t\tusedClasses = {Address.class}))\r\n\tprivate Address address;\r\n\tprivate boolean enabled = true;\r\n\tprivate Gender gender;\r\n\tprivate Date birthDate;\r\n\t@RowMapperEnumField(enumStartValue = 1)\r\n\tprivate Language language;\r\n\t@RowMapperEnumField(\r\n\t\t\tmapViaAutoMapper = \r\n\t\t\t\t@RowMapperEnumAutoMapper(\r\n\t\t\t\t\t\tmapViaNumericValueNumericMappings = {\r\n\t\t\t\t\t\t\t\t@RowMapperEnumNumericValueNumericMapping(mappingIndex = 0, value = 0),\r\n\t\t\t\t\t\t\t\t@RowMapperEnumNumericValueNumericMapping(mappingIndex = 1, value = 100),\r\n\t\t\t\t\t\t\t\t@RowMapperEnumNumericValueNumericMapping(mappingIndex = 2, value = 200),\r\n\t\t\t\t\t\t\t\t@RowMapperEnumNumericValueNumericMapping(mappingIndex = 3, value = 300),\r\n\t\t\t\t\t\t\t\t@RowMapperEnumNumericValueNumericMapping(mappingIndex = 4, value = 400),\r\n\t\t\t\t\t\t\t\t@RowMapperEnumNumericValueNumericMapping(mappingIndex = 5, value = 500),\r\n\t\t\t\t\t\t\t\t@RowMapperEnumNumericValueNumericMapping(mappingIndex = 6, value = 600),\r\n\t\t\t\t\t\t\t\t@RowMapperEnumNumericValueNumericMapping(mappingIndex = 7, value = 700)\r\n\t\t\t\t\t\t}))\r\n\tprivate Occupation occupation;\r\n\t@RowMapperEnumField(\r\n\t\t\tmapViaAutoMapper = \r\n\t\t\t\t@RowMapperEnumAutoMapper(\r\n\t\t\t\t\t\tmapViaStringValueNumericMappings = {\r\n\t\t\t\t\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 0, value = \"PRIMARY_SCHOOL\"),\r\n\t\t\t\t\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 1, value = \"SECONDARY_SCHOOL\"),\r\n\t\t\t\t\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 2, value = \"HIGH_SCHOOL\"),\r\n\t\t\t\t\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 3, value = \"BACHELOR\"),\r\n\t\t\t\t\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 4, value = \"MASTER\"),\r\n\t\t\t\t\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 5, value = \"PHD\"),\r\n\t\t\t\t\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 6, value = \"ASSOCIATE_PROFESSOR\"),\r\n\t\t\t\t\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 7, value = \"PROFESSOR\"),\r\n\t\t\t\t\t\t\t\t@RowMapperEnumStringValueNumericMapping(mappingIndex = 8, value = \"OTHER\")\r\n\t\t\t\t\t\t}))\r\n\tprivate Education education;\r\n\t@RowMapperEnumField(\r\n\t\t\tmapViaNumericMapper = \r\n\t\t\t\t@RowMapperEnumNumericMapper(\r\n\t\t\t\t\t\t\tmapper = BloodTypeEnumMapper.class))\r\n\tprivate BloodType bloodType;\r\n\t@RowMapperEnumField(\r\n\t\t\tmapViaStringMapper = \r\n\t\t\t\t@RowMapperEnumStringMapper(\r\n\t\t\t\t\t\t\tmapper = MaritalStatusEnumMapper.class))\r\n\tprivate MaritalStatus maritalStatus;\r\n\t@RowMapperEnumField(useStringValue = true)\r\n\tprivate Religion religion;\r\n\t@RowMapperObjectField(\r\n\t\t\tprovideViaExpressionProvider = \r\n\t\t\t\t@RowMapperExpressionProvider(\r\n\t\t\t\t\t\texpression = \"@{roleDAO}.getUserRoleList(${id})\"),\t\t\r\n\t\t\tlazy = true,\r\n\t\t\tlazyCondition = \r\n\t\t\t@RowMapperLazyCondition(\r\n\t\t\t\t\tprovideViaCustomProvider = \r\n\t\t\t\t\t\t@RowMapperCustomLazyConditionProvider(\r\n\t\t\t\t\t\t\t\tlazyConditionProvider = UserRolesLazyConditionProvider.class)))\r\n\tprivate List<Role> roles;\r\n\t@RowMapperObjectField(\r\n\t\t\tprovideViaExpressionProvider = \r\n\t\t\t\t@RowMapperExpressionProvider(\r\n\t\t\t\t\texpression = \"@{creditCardInfoDAO}.getUserCreditCardInfo(${id})\"),\t\t\r\n\t\t\tlazy = true,\r\n\t\t\tlazyCondition = \r\n\t\t\t\t@RowMapperLazyCondition(\r\n\t\t\t\t\tprovideViaPropertyBasedProvider = \r\n\t\t\t\t\t\t@RowMapperPropertyBasedLazyConditionProvider(\r\n\t\t\t\t\t\t\t\tpropertyName = \"creditCardInfoLazyCondition\")))\r\n\tprivate CreditCardInfo creditCardInfo;\r\n\t@RowMapperObjectField(\r\n\t\t\tprovideViaExpressionProvider = \r\n\t\t\t\t@RowMapperExpressionProvider(\r\n\t\t\t\t\texpression = \"@{creditCardInfoDAO}.getUserSecondaryCreditCardInfo(${id})\"),\t\t\r\n\t\t\tlazy = true,\r\n\t\t\tlazyCondition = \r\n\t\t\t@RowMapperLazyCondition(\r\n\t\t\t\t\tprovideViaPropertyBasedProvider = \r\n\t\t\t\t\t\t@RowMapperPropertyBasedLazyConditionProvider(\r\n\t\t\t\t\t\t\t\tpropertyName = \"creditCardInfoLazyCondition\")))\r\n\tprivate CreditCardInfo secondaryCreditCardInfo;\r\n\t@RowMapperObjectField(\r\n\t\t\tprovideViaExpressionProvider = \r\n\t\t\t\t@RowMapperExpressionProvider(\r\n\t\t\t\t\texpression = \"@{creditCardInfoDAO}.getUserCreditCardInfo(${id})\"),\t\t\r\n\t\t\tignoreCondition = \r\n\t\t\t\t@RowMapperIgnoreCondition(\r\n\t\t\t\t\tprovideViaPropertyBasedProvider = \r\n\t\t\t\t\t\t@RowMapperPropertyBasedIgnoreConditionProvider(\r\n\t\t\t\t\t\t\t\tpropertyName = \"creditCardInfoIgnoreCondition\")))\r\n\tprivate CreditCardInfo previousCreditCardInfo;\r\n\t\r\n\t@RowMapperIgnoreField // Or define field as transient\r\n\tprivate byte age;\r\n~~~~~\r\n\r\nHere is `Role` class:    \r\n\r\n~~~~~ java\r\n@RowMapperClass(objectCreater = RoleObjectCreater.class)\r\npublic class Role {\r\n\r\n\tprivate Long id;\r\n\t@RowMapperField(fieldMapper = RoleNameFieldMapper.class)\r\n\tprivate String name;\r\n\t@RowMapperObjectField(\r\n\t        provideViaSqlProvider = \r\n\t            @RowMapperSqlProvider(\r\n\t                provideSql = \r\n\t                    \"SELECT p.* FROM PERMISSION p WHERE p.ID IN \" +\r\n\t                    \"(\" +\r\n\t                        \"SELECT rp.PERMISSION_ID FROM role_permission rp WHERE rp.ROLE_ID = ${id}\" +\r\n\t                    \") ORDER BY p.name\",\r\n\t                entityType = Permission.class),\t    \r\n\t        lazy = true,\r\n\t        lazyCondition = \r\n\t\t\t@RowMapperLazyCondition(\r\n\t\t\t\tprovideViaExpressionBasedProvider = \r\n\t\t\t\t\t@RowMapperExpressionBasedLazyConditionProvider(\r\n\t\t\t\t\t\texpression = \"${name}.equals(\\\"Member\\\")\")))\r\n\tprivate List<Permission> permissions;\r\n\r\n    ...\r\n    \r\n}\r\n~~~~~\r\n\r\nHere is `BloodTypeEnumMapper` class:  \r\n\r\n~~~~~ java\r\npublic class BloodTypeEnumMapper implements RowMapperEnumField.NumericEnumMapper<BloodType> {\r\n\r\n\t@Override\r\n\tpublic BloodType map(Integer value) {\r\n\t\tfor (BloodType bt : BloodType.values()) {\r\n\t\t\tif (bt.getCode() == value) {\r\n\t\t\t\treturn bt;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n}\t\r\n~~~~~\r\n\r\nHere is `MarialStatusEnumMapper` class:  \r\n\r\n~~~~~ java\r\npublic class MaritalStatusEnumMapper implements RowMapperEnumField.StringEnumMapper<MaritalStatus> {\r\n\r\n\t@Override\r\n\tpublic MaritalStatus map(String value) {\r\n\t\tfor (MaritalStatus ms : MaritalStatus.values()) {\r\n\t\t\tif (ms.name().equalsIgnoreCase(value)) {\r\n\t\t\t\treturn ms;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n}\t\r\n~~~~~\r\n\r\nHere is `UserPhoneNumberFieldProvider` class:  \r\n\r\n~~~~~ java\r\npublic class UserPhoneNumberFieldProvider implements RowMapperFieldProvider<User, String> {\r\n\r\n\tprivate final static Logger logger = Logger.getLogger(UserPhoneNumberFieldProvider.class);\r\n\t\r\n\t@Override\r\n\tpublic String provideField(User user, String fieldName, ResultSet rs, int rowNum) {\r\n\t\ttry {\r\n\t\t\treturn rs.getString(\"phone_number\");\r\n\t\t} \r\n\t\tcatch (SQLException e) {\r\n\t\t\tlogger.error(\"Error occured while mapping field \" + fieldName + \" in User object from resultset\", e);\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n~~~~~\r\n\r\nHere is `UserRolesLazyConditionProvider` class:  \r\n\r\n~~~~~ java\r\npublic class UserRolesLazyConditionProvider implements RowMapperLazyConditionProvider<User> {\r\n\r\n\tprivate final static Logger logger = Logger.getLogger(UserRolesLazyConditionProvider.class);\r\n\t\r\n\t@Override\r\n\tpublic boolean evaluateCondition(User user, String fieldName, ResultSet rs, int rowNum) {\r\n\t\tboolean conditionResult = user.getId() % 2 == 0;\r\n\t\tlogger.debug(\"Evaluated lazy condition of field \" + \"\\\"\" + fieldName + \"\\\"\" +  \r\n\t\t\t \" for user with id \" + \"\\\"\" + user.getId() + \"\\\"\" + \" as \" + \"\\\"\" + conditionResult + \"\\\"\");\r\n\t\treturn conditionResult;\r\n\t}\r\n\r\n}\t\r\n~~~~~\r\n\r\nHere is `UserObjectProcessor` class:  \r\n\r\n~~~~~ java\r\npublic class UserObjectProcessor implements RowMapperObjectProcessor<User> {\r\n\r\n\t@SuppressWarnings(\"deprecation\")\r\n\t@Override\r\n\tpublic void processObject(User user, ResultSet rs, int rowNum) {\r\n\t\tif (user.getBirthDate() != null) {\r\n\t\t\tuser.setAge((byte)(Calendar.getInstance().getTime().getYear() - user.getBirthDate().getYear()));\r\n\t\t}\r\n\t}\r\n\r\n}\r\n~~~~~\r\n\r\nHere is `RoleObjectCreater` class:  \r\n\r\n~~~~~ java\r\npublic class RoleObjectCreater implements RowMapperObjectCreater<Role> {\r\n\r\n\t@Override\r\n\tpublic Role createObject(Class<Role> clazz) {\r\n\t\treturn new Role();\r\n\t}\r\n\r\n}\r\n~~~~~\r\n\r\nHere is `RoleNameFieldMapper` class:  \r\n\r\n~~~~~ java\r\npublic class RoleNameFieldMapper implements RowMapperFieldMapper<Role> {\r\n\r\n\tprivate static final Logger logger = Logger.getLogger(RoleNameFieldMapper.class);\r\n\t\r\n\t@Override\r\n\tpublic void mapField(Role role, String fieldName, ResultSet rs, int rowNum) {\r\n\t\ttry {\r\n\t\t\trole.setName(rs.getString(\"name\"));\r\n\t\t} \r\n\t\tcatch (SQLException e) {\r\n\t\t\tlogger.error(\"Error occured while mapping field \" + fieldName + \r\n\t\t\t\t\t\" in Role object from resultset\", e);\r\n\t\t}\r\n\t}\r\n\r\n}\r\n~~~~~\r\n\r\nHere is `UserAccountInfoSqlQueryInfoProvider` class:  \r\n\r\n~~~~~ java\r\npublic class UserAccountInfoSqlQueryInfoProvider implements RowMapperSqlQueryInfoProvider<User> {\r\n\r\n\t@Override\r\n\tpublic SqlQueryInfo provideSqlQueryInfo(User user, String fieldName) {\r\n\t\treturn \r\n\t\t\tnew SqlQueryInfo(\r\n\t\t\t\t\"SELECT a.* FROM ACCOUNT_INFO a WHERE a.ID IN \" +\r\n\t            \"(\" +\r\n\t                \"SELECT ua.account_info_id FROM USER_ACCOUNT_INFO ua WHERE ua.user_id = ?\" +\r\n\t            \")\",\r\n\t            new Object[] { user.getId() });\r\n\t}\r\n\r\n}\r\n~~~~~ \r\n\r\nHere is `CreditCardInfoJdbcDAO` class:  \r\n\r\n~~~~~ java\r\n@Repository(value=\"creditCardInfoDAO\")\r\npublic class CreditCardInfoJdbcDAO extends BaseJdbcDAO implements CreditCardInfoDAO {\r\n\r\n\t...\r\n\t\r\n\t@Override\r\n\t@RowMapperPropertyBasedLazyConditionAware(\r\n\t\tpropertyName = \"creditCardInfoLazyCondition\",\r\n\t\toptions = \tRowMapperPropertyBasedLazyConditionAware.ENABLE_ON_START | \r\n\t\t\t\tRowMapperPropertyBasedLazyConditionAware.DISABLE_ON_FINISH)\r\n\tpublic CreditCardInfo getUserSecondaryCreditCardInfo(Long userId) {\r\n\t\tlogger.debug(\"Getting secondary credit card info for user with id \" + userId);\r\n\t\treturn \r\n\t\t\tjdbcTemplate.queryForObject(\r\n\t\t\t\t\"SELECT c.* FROM CREDIT_CARD_INFO c WHERE c.id = \" +\r\n\t\t\t\t\"(\" +\r\n\t\t\t\t\t\"SELECT uc.credit_card_info_id FROM USER_SECONDARY_CREDIT_CARD_INFO uc WHERE uc.user_id = \" + userId +\r\n\t\t\t\t\")\", \r\n\t\t\t\tcreditCardInfoRowMapper);\r\n\t}\r\n\r\n}\r\n~~~~~\r\n\r\nYou can get `User` entity rowmapper as follows:\r\n\r\n~~~~~ java\r\n@Autowired\r\nRowMapperService rowMapperService;\r\n    \r\n...\r\n\r\nRowMapper<User> userRowMapper = rowMapperService.getRowMapper(User.class);\r\n~~~~~\r\n\r\nIn this example, we can get related `Role` entites of `User` entity with **`@RowMapperObjectField`** annotion automatically. \r\nWe use **`@RowMapperObjectField`** annotation for accessing related `Role` entites of `User` entity with `id` attribute of User. \r\nWe have **`lazy=true`** configuration, since `roles` field are initialized while we are accessing it first time. \r\nIf we don't access it, it will not be set. \r\n\r\nYou can find all demo codes (including these samples above) at [https://github.com/serkan-ozal/spring-jdbc-roma-demo](https://github.com/serkan-ozal/spring-jdbc-roma-demo)\r\n \r\n\r\n<a name=\"Section_6\"></a> \r\n6. Roadmap\r\n=======\r\n\r\n* In addition to Annotation based configuration **XML** and **Properties** file based configuration support will be added.\r\n\r\n* Spring context xml specific XSD will be defined and configuration can be done in Spring context xml by using **<roma>** tags.\r\n\r\n* Integration with [https://github.com/nurkiewicz/spring-data-jdbc-repository](https://github.com/nurkiewicz/spring-data-jdbc-repository) which is Spring Data JDBC generic DAO implementation framework by [Tomasz Nurkiewicz](https://github.com/nurkiewicz).\r\n\r\n* Generic DAO implementaion will be added for CRUD operations such as **get**, **list**, **add**, **update** and **delete** by considering object relations and different DBMS vendors (Oracle, MySQL, PostgreSQL, ...)\r\n","google":"UA-49968563-1","note":"Don't delete this file! It's used internally to help with page regeneration."}